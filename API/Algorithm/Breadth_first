local version = "1.01"

local node
local openedNodeList

function getRoute(w, d, f, min, max, canPass, isGoal)
  initNode(min, max)
  openedNodeList[1] = {}
  openNode(1, w, d, f, {})
  for i, var1 in ipairs(openedNodeList) do
    for j, var2 in ipairs(openedNodeList[i]) do
      route = closeNode(i, var2.width, var2.depth, canPass, isGoal)
      if (route ~= nil) then return route end
    end
  end
  return {}
end

function initNode(min, max)
  node = {}
  openedNodeList = {}
  for i = min.W, max.W do
    node[i] = {}
    for j = min.D, max.D do
      node[i][j] = {state = "none"}
    end
  end
end

function getNodeState(w, d)
  if (node[w] == nil) then return "outside" end
  if (node[w][d] == nil) then return "outside" end
  return node[w][d].state
end

function openNode(cost, w, d, f, log)
  node[w][d] = {state = "open", face = f, route = log}
  table.insert(openedNodeList[cost], {width = w, depth = d})
end

function closeNode(cost, w, d, canPass, isGoal)
  local prevF = node[w][d].face
  local prevRoute = node[w][d].route
  
  node[w][d].state = "close"
  
  -- making dummy
  openedNodeList[cost + 1] = openedNodeList[cost + 1] or {}
  openedNodeList[cost + 2] = openedNodeList[cost + 2] or {}
  openedNodeList[cost + 3] = openedNodeList[cost + 3] or {}
  
  local rateC = {}
  -- Forward
  rateC[0] = cost + 1
  -- Right
  rateC[1] = cost + 2
  -- Back
  rateC[2] = cost + 3
  -- Left
  rateC[3] = cost + 2
  
  for i = 0, 3 do
    local nextC = rateC[i]
    local nextF = (prevF + i) % 4
    local nextW, nextD = getAdjacentPos(nextF, w, d)
    local nextRoute = {unpack(prevRoute)}
    table.insert(nextRoute, {face = nextF, dir = direction.FORWARD})
    if (getNodeState(nextW, nextD) == "none") then
      if (isGoal(nextW, nextD)) then
        return nextRoute
      end
      if (canPass(nextW, nextD)) then
        openNode(nextC, nextW, nextD, nextF, nextRoute)
      end
    end
  end
  return nil
end